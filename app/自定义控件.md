
#　控件的绘制

## Paint

    setPaint
    setARGB
    setAlpha
    setAntiALias
    setColor
    setColorFilter
        ColorFilter
            ColorMatrixColorFilter
            LightingColorFilter
            PorterDuffColorFilter
    setXfermode
        Xfermode
            AvoidXfermode
            PixelXFermode
            PorterDuffXfermode
                PorterDuffMode
                    ADD             饱和相加
                    CLEAR           清除
                    DARKEN          变暗
                    DST             只绘制目标图片
                    DST_ATOP        在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像
                    DST_IN          只在源图像和目标图像相交的地方绘制目标图像
                    DST_OUT         只在源图像和目标图像不相交的地方绘制目标图像
                    DST_OVER        在源图像的上方绘制目标图像
                    LIGHTEN         变亮
                    MULTIPLY        正片叠底
                    OVERLAY         叠加
                    SCREEN          滤色  让图像焦媃幻化，有一种色调均和的感觉
                    SRC             显示源图
                    SRC_ATOP        在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像
                    SRC_IN          只在源图像和目标图像相交的地方绘制源图像
                    SRC_OUT         只在源图像和目标图像不相交的地方绘制源图像
                    SRC_OVER        在目标图像的顶部绘制源图像
                    XOR             在源图像和目标图像重叠之外的任何地方绘制他们，而在不重叠的地方不绘制任何内容

    FontMetrics
        ascent
        descent
    getFontMetrics
    getFontMetricsInt
    setTypeface
    setTextAlign
    setMaskFilter
        MaskFilter
            BlurMaskFilter
            EmbossMaskFilter
    setPathEffect
        PathEffect
            ComposePathEffect
            ComerPathEffect
            DashPathEffect
            DiscretePathEffect
            PathDashPathEffect
            SumPathEffect
    setStrokeCap
    setStrokeJoin
    setShadowLayer
    setShader 着色器

        Shade.TileMode
            CLAMP
            REPEAT
            MIRROR

        BitmapShader
        ComposeShader
        LinerGradient
        RadialGradient
        SweepGradient

##Matrix
    平移
    缩放
    旋转
    错切
    透视

    setXXX
    preXXX
    postXXX



##Canvas

### drawXXX为主的绘制方法

### clipXXX为主的裁剪方法

    clipRect
        Rect
            union
            intersect
        Region

    clipPath
        Path
            lineTo 连接至某个坐标
            moveTo 改变起始点
            close
            quadTo 二阶贝塞尔曲线
            arcTo
            addArc

    Region  区域
    Region.OP 组合模式
            DIFFERENCE          最终区域为第一个区域与第二个区域不同的区域。
            INTERSECT           最终区域为第一个区域与第二个区域相交的区域。
            REPLACE             最终区域为第二个区域。
            REVERSE_DIFFERENCE  最终区域为第二个区域与第一个区域不同的区域。
            UNION               最终区域为第一个区域加第二个区域。
            XOR                 最终区域为第一个区域加第二个区域并减去两者相交的区域。

    Region和Rect有什么区别呢？
            Region表示的是一个区域，而Rect表示的是一个矩形
            Region有个很特别的地方是它不受Canvas的变换影响，Canvas的local不会直接影响到Region自身

### saveXXX和restoreXXX画布锁定和还原

    通过saveXXX和restoreXXX来模拟图层的效果

    canvas是一个容器

    如果说Canvas理解成画板，那么“层”就是一张张夹在画板上透明的纸，而这些纸则是一个个封装在Canvas中的Bitmap

    save和saveLayerXXX有着很大的区别，但是在一般应用上两者的功能是差不多的。

        save
            在当前的Bitmap中进行操作，管理依靠stack栈进行
        restore

        saveLayer
            会将所有的操作保存到一个新的Bitmap中，而不影响当前Canvas的Bitmap
        restoreToCount

        flag
            ALL_SAVE_FLAG               新手级常用的标识保存所有
            CLIP_SAVE_FLAG              裁剪的标识位
            CLIP_TO_LAYER_SAVE_FLAG     当前图层执行裁剪操作需要对齐图层边界
            FULL_COLOR_LAYER_SAVE_FLAG  当前图层的色彩模式至少需要是8位色
            HAS_ALPHA_LAYER_SAVE_FLAG   当前图层中将需要使用逐像素Alpha混合模式
            MATRIX_SAVE_FLAG            换的标识位

### scale/skew/translate/rotate等变换方法


# 控件的测量

    Activity
        PhoneWindow(Window)
            DecorView(FrameLayout)  com.android.internal.R.id.content (真正的根视图)
                OurContent

    Android GUI MVC
        V - View                        显示数据／测量布局／绘制／动画
        C - ViewRootImpl(Bridge)        窗口的显示／用户的输入／绘制流程的控制（performTraversals()是处理绘制流程的开始）

        performTraversals();

        ```java
        if (!mStopped || mReportNextDraw) {
            boolean focusChangedDueToTouchMode = ensureTouchModeLocally(
                    (relayoutResult&WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
            if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()
                    || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {\

                // 重点
                int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
                int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);

                 // Ask host how big it wants to be
                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);


                .....
        }
        ```

        ```java
        private static int getRootMeasureSpec(int windowSize, int rootDimension) {
            int measureSpec;
            switch (rootDimension) {

            case ViewGroup.LayoutParams.MATCH_PARENT:
                // Window不能调整其大小，强制使跟视图大小与window一致
                // Window can't resize. Force root view to be windowSize.
                measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
                break;
            case ViewGroup.LayoutParams.WRAP_CONTENT:
                // Window可以调整其大小，为跟视图设置一个最大值
                // Window can resize. Set max size for root view.
                measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
                break;
            default:
                // Window想要一个确定的尺寸，强制将跟视图尺寸作为其尺寸
                // Window wants to be an exact size. Force root view to be that size.
                measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
                break;
            }
            return measureSpec;
        }
        ```

        执行完getRootMeasureSpec()之后，不管如何，我们的跟视图大小必定是全屏的

        至此，才是真正接触到跟视图的测量规格，这个规格会由上至下传递下去，并由当前view与其父容器共同作用决定最终的测量大小。

    测量过程 measure()
        onMeasure()

        ```java
        protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
            // 省去部分代码……

            // 设置测量后的宽高
            mMeasuredWidth = measuredWidth;
            mMeasuredHeight = measuredHeight;

            // 重新将已测量标识位存入mPrivateFlags标识测量的完成
            mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
        }
        ```

        ```java
        public static int getDefaultSize(int size, int measureSpec) {
            // 将我们获得的最小值赋给result
            int result = size;

            // 从measureSpec中解算出测量规格的模式和尺寸
            int specMode = MeasureSpec.getMode(measureSpec);
            int specSize = MeasureSpec.getSize(measureSpec);

            /*
             * 根据测量规格模式确定最终的测量尺寸
             */
            switch (specMode) {
            case MeasureSpec.UNSPECIFIED:
                result = size;
                break;
            case MeasureSpec.AT_MOST:
            case MeasureSpec.EXACTLY:
                result = specSize;
                break;
            }
            return result;
        }
        ```
        上述代码中当模式为AT_MOST和EXACTLY时均会返回解出的测量值。
        从PhoneWindow、DecorView它们那里获取到的测量规格层层传递到我们的自定义View中，这就是为什么我们的View在默认情况下不管是math_parent还是warp_content都能占满父容器的剩余空间。
        上述onMeasure()的过程是View默认的处理过程。

    MeasureSpec
        UNSPECIFIED     未指定     爹不会对儿子作任何的束缚，儿子想要多大都可以
        EXACTLY         完全的     儿子多大爹心里有数，爹早已算好了
        AT_MOST         至多       爹已经为儿子设置好了一个最大限制，儿子你不能比这个值大，不能再多了


    View的测量大小是和其父容器共同决定的　（ViewGroup measureChildren measureChild measureChildWithMargins getChildMeasureSpec）

# 控件的交互行为